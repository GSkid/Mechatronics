# Mechatronics
### Fall 2019 Semi-annual Mechatronics Competition at UCSC

## Project Overview
This mechatronics project was completed for UCSC's semi-annual mechatronics competition for Fall 2019 where Grant, in addition to two teammates, built a robot from scratch to complete a specific course. The goal of this project was to create a fully autonomous robot able to navigate around a lightcolored field, locate an IR beacon tower, and dispense ping-pong balls into indicated drop-off holes. In the design process of this project, we incorporated topics such as signal manipulation, mechanical prototyping, sensor integration, and state machine logic. Our constraints for this project included a $150 budget and maximum size dimensions for our robot of an 11 inch cube. Our final design included two ping sensors mounted at the front left and back left corners, facing the left, to allow the robot to recenter and align its left side with the tower. We went with a simplified launch mechanism using a single dispenser tower in the middle, facing the left as well, with a tape sensor to correctly identify where to dispense the balls. As for the launch mechanism itself, we used a DC motor to operate a spinning rotor which pushed out ping pong balls and relied on gravity to drop the ping pong balls down the angled dispensing tube, where its opening aligned with the mouth of the hole on the towers. The final design was able to complete the course with a 100% success rate of dispensing a ball in 2 out of 3 correct holes. In the actual competition, our bot placed 2nd among the 18 competing teams. With the overview out of the way, the rest of this readme will focus specifically on the software design.

## Software Design of the Robot
The software for our robot was based off the ES Framework developed by J. Edward Carryer of Stanford University and revised by Gabriel Hugh Elkaim of UC Santa Cruz. This software uses C to program a Microchip Uno32 microcontroller, which was used as a way of interfacing and
controlling the inputs and outputs of the robot. The software is comprised of three central parts: events, services, and the hierarchical state machine (HSM).

First off, the events function as continually running routines that are useful for checking things like the beacon detector and the tape sensors. However, we decided not to use any events in the final iteration of the bot. Instead we opted to institute all sensor input checking with services. Services are similar to events, but they give the user the ability to control the rate at which input signals are checked as well as having the option to completely to turn the service on or off. The final part was the hierarchical state machine, which is just a method of implementing nested state machines. Having these nested state machines made the organization of control logic much more intuitive, without which we may not have been able to complete the project on time.

## Services
Services are the way the robot interacts with the external sensor inputs. These inputs alterted the robot to changes in the environment, such as when the robot was pointed in the direction of a tower or when the robot was about to go out of bounds. We implemented 4 services, BeaconDetectorService.c, BumperService.c, PingService.c, and TapeSensorService.c, all of which are accompanied by respective header files. When these services detect a change in the environment, they effectively post a notification to the hierarchichal state machine that triggers changes in specific states (if applicable), this will be discussed further in the next section. The services all operate sequentially so that each service is checked at the appropriate time depeinding on clock cycles and configuration settings. However, there is no chance that two services can post an update to the HSM at the same time, meaning that there will only ever be a single notification pushed to the HSM at a time. The HSM will resolve the service routine and then return to the next service in sequence, similar to an ISR.

## The Hierarchichal State Machine
The HSM provides the control logic for the robot, telling what to do based on inputs from the services. The HSM can also access functions that control outputs like motor speed and the ball dispensing mechanism through the I/O pins. In all, this means the HSM provides the program flow and error checking capabilities to ensure the robot never gets stuck in a single state. All of the states of the HSM are listed here in descending order (highest level to lowest level): TopLevelHSM.c, DrivingSubHSM.c, DancingSubHSM.c, LocateHoleHSM.c.

The HSM is a depth-first hierarchichal state machine, meaning that when events are generated through the service routines, the events are first sent to the lowest level state machine possible. This allows us to nest state machines while still providing a priority system for the service events where the priority is placed on the most specific state machines and then moving back up toward the most general state machine. If a state machine at a lower level consumes an event from a service, that event is cleaned out and no other state machines are able to use that event. But when no state machine uses an event, then the HSM just neglects the event altogether and returns the control back over to the service checking routines. The HSM proved to be an effective way of managing the robot while still preserving a reactive system that was able to quickly adapt to external conditions.

## What I Learned From This Project
There are a lot of things I learned here: using the input capture, outputting PWM signals to control motors, debugging a large HSM system, dealing with power distribution in the most efficient manner, incororating custom sensors into a state machine, laser cutting, and lots of other things. Outside of technical skills, I learned the importance of planning every step and having a good understaning of the course in order to create design objectives. And most importantly, I improved on my skills with time management. Choosing to stay over the thanksgiving break to finish the robot while my other two teammates went home was the difference maker between finishing the robot on time and submitting it late. I feel like a much better understanding of how electronics interact with microcontrollers (and by extension coding) and physical fabrication to create a full mechatronic system. 